1. main.py + main.qml fájlok (a fájlnév kis kezdőbetűvel)

2. qml_components mappa, azon belül qml fájlok nagy kezdőbetűvel + custom_components mappa, benne qml fájlok 
nagy kezdőbetűvel

3. ha vannak képek, akkor azokat egy resources mappába gyűjteni

4. ha kell oldalváltás az applikációban, akkor azt state-ekkel lehet megcsinálni (Qt dokumentáció (doc.qt.io))

5. py_components mappa, azon belül kell egy __init__.py fájl

6. minden olyan python class, amit hozzá akarunk adni a qml context-hez, annak a QObject-ből kell örökölnie

7. a main.py fájlban lévő class konstruktorában beszúrjuk a python class-okat a qml rétegbe

8. kell egy hozzáférés (request) az adatbázishoz (tmdb_test.py fájl)

9. ha egy Qt view-ban adatokat akarunk megjeleníteni, akkor kell egy modell, vagyis egy speciális 
python osztály, amiben adatok vannak, és ez mindig a QAbstractListModel-ből örököl (a modell elő van készítve 
úgy, hogy egy vagy több Qt view-val tud kommunikálni)

10. minden olyan class, ami abstract, abban bizonyos attribútumokat és metódusokat kötelező definiálni, még
mielőtt egy ilyen class-t bárhol példányosítunk (Qt dokumentáció (doc.qt.io))

11. The design of a Qt application development.png

12. bind-olás (egy python class-ban lévő Qt property-k (Property, NEM @property) "összekötése" egy/több qml
file-ban lévő változóval/változókkal (qml változó pl. a visible:)); ennek a menete: egy python class-ban
lévő változó = Property(bool, getter, setter, notify=Signal()), egy qml fájlban lévő változó 
(pl. a visible: python osztály.Property név)

13. az applikációban történő keresés esetén a begépelt karaktersorozat nem egy "eredeti" modellhez, hanem az 
ebből a modellből létrehozott proxymodelhez jut el, ami végigiterál az "eredeti" modellen, és a keresésnek meg-
felelően kitöröl mindent és frissít, és csak olyan filmek lesznek a proxymodelben, amit meg kell a view-nak
jelenítenie; tehát az "eredeti" modellnek csak el kell mennie az adatbázishoz és kérni az adatbázisból az 
adatokat, feltöltődik a modell és a proxymodel és azt látja a view; ha sortolni/filterezni akarunk a találati
listában, akkor már csak a proxymodel frissül